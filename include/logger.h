/*
 * Copyright (C) 2015  Brendan Bruner
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * bbruner@ualberta.ca
 */
/**
 * @file logger.h
 * @author Brendan Bruner, Haoran Qi
 * @date May 14, 2015
 */
#ifndef INCLUDE_TELEMETRY_LOGGER_H_
#define INCLUDE_TELEMETRY_LOGGER_H_

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <redposix.h>

/*FreeRTOS includings*/
#include <FreeRTOS.h>
#include <os_task.h>
#include <os_semphr.h>

#include "main/system.h"

/*  when master table is erased and only writes are done it keeps on chugging. */
/* Error checks need to be put in place EVERY time master table is opened and a */
/* recover_master_table( ) function needs to be made to help recover. */
/* For example, us the OPEN_EXISTING flag when opening master table. */

/********************************************************************************/
/* Defines																		*/
/********************************************************************************/
#define LOGGER_TOTAL_SEQUENCE_BYTES 3
#define LOGGER_SEQUENCE_START 0
#define LOGGER_SEQUENCE_BASE 16

#define LOGGER_MAX_CAPACITY (LOGGER_SEQUENCE_BASE*LOGGER_SEQUENCE_BASE*LOGGER_SEQUENCE_BASE) /* DO NOT CHANGE THIS DERRRR */ /* Numbers greater cause overflow in an undefined way */
#define LOGGER_MIN_CAPCITY (2)

#define LOGGER_MAX_TEMPORAL_POINTS (10*10*10*10)
#define LOGGER_TOTAL_TEMPORAL_BYTES 4
#define LOGGER_TEMPORAL_START (LOGGER_SEQUENCE_START+LOGGER_TOTAL_SEQUENCE_BYTES+1)

/* Configuration defines from filesystems*/
#define FILESYSTEM_FATFS_MAX_FILE_HANDLES 	20
#ifdef NANOMIND
#define FILESYSTEM_FATFS_MAX_DIR_HANDLES 	0
#else
#define FILESYSTEM_FATFS_MAX_DIR_HANDLES 	1
#endif
#define FILESYSTEM_MAX_NAME_LENGTH 			12

/*FreeRTOS Portable Definitions*/
#define bool_t bool
#define MUTEX_TURE (bool_t)1
#define MUTEX_FALSE (bool_t)0
#define mutex_t SemaphoreHandle_t
#define DEV_ASSERT( pointer ) configASSERT( (pointer) )



/********************************************************************************/
/* Structure Documentation														*/
/********************************************************************************/
/**
 * @struct logger_t
 * @brief
 * 		Structure which abstracts a ring buffer in non volatile memory.
 * @details
 * 		Provides an API to non volatile memory which supports a ring buffer topology. This ring buffer
 * 		manages files (ie, files are the elements of the ring buffer). This API enables
 * 		the insertion of files into the HEAD and removal of files from the TAIL. In addition, it is conducive to
 * 		asynchronous file removal via any type of FTP. In other words, it will correct it's TAIL location
 * 		when elements of the ring buffer have been asynchronously removed by an FTP.
 *
 * 		Files under control of the logger follow a strict naming convention:
 * 		<br><b>aaaXbbbb.bin</b>
 * 		<br><ul>
 * 		<li><b>aaa</b>: Sequencing meta data used by the ring buffer to maintain itself. These are numbers to indicate where
 * 		in the ring buffer the file is located (much like an array index).</li>
 * 		<li><b>X</b>: Unique name of file elements in the ring buffer. This is the only variable chosen by the application
 * 		programmer and is used to distinguish between files that are, say, from the DFGM vs MnLP.</li>
 * 		<li><b>bbbb</b>: temporal data generated by the ring buffer so that users can distinguish files based on relative time. bbbb is a number
 * 		which gets incremented relative to the previously inserted files. A larger bbbb value means the file was more recently generated.
 * 		Of course, this number will eventually roll over.</li>
 * 		</ul>
 *
 * 		Files removed from the ring buffer via logger_t::logger_pop_file( ) are renamed to this convention:
 * 		<br><b>Xaaaaaaa.bin</b>
 * 		<br><ul>
 * 		<li><b>X</b>: Has the same meaning as before.</li>
 * 		<li><b>aaaaaaa</b>: Is a relative number. This number is incremented for each file that gets popped. A small value indicates the file
 * 		popped earlier than a file with a large value. Of course, this number rolls over.
 * @var logger_t::control_file_name;
 * 		<b>Private</b>
 * 		The name of a file which contains meta data about packet files. The file is structured
 * 		like this:
 * 		| HEAD (LOGGER_MAX_FILE_NAME_LENGTH+1 bytes) | TAIL (LOGGER_MAX_FILE_NAME_LENGTH+1 bytes) |
 * 		| HEAD sequence data (3 bytes) | HEAD temporal data (4 bytes) | popped temporal data (7 bytes) | reserved (2 bytes) |
 * 		<b>Private</b>
 * 		Length of logger_t::_packet_name_, does not include the null character.
 * @var logger_t::element_file_name
 * 		The unique name of elements in the ring buffer.
 * @var logger_t::filesystem;
 * 		<b>Private</b>
 * 		The filesystem used by the logger.
 * @var logger_t::sync_mutex;
 * 		<b>Private</b>
 * 		Mutex used for mutual exclusion. This is a singleton shared by all logger instances.
 */
typedef struct logger_t logger_t;

/** Error codes returned by logger_t methods. */
typedef enum
{
	LOGGER_OK = 0,		/*!< (0) Succeeded. */
	LOGGER_NVMEM_ERR,	/*!< (1) An error occurred interacting with non volatile memory.
	 	 	 	 	 	 	 	 operation aborted, no changes made. */
	LOGGER_MUTEX_ERR,	/*!< (2) Failed to create synchronization objects. */
	LOGGER_EMPTY,		/*!< (3) No files in the loggers buffer to peek / pop. */
	LOGGER_NVMEM_FULL,	/*!< (4) Non volatile memory is full. */
	LOGGER_INV_CAP		/*!< (5) Returns by constructor when an invalid capacity is used. */
} logger_error_t;


/********************************************************************************/
/* Structure Definition															*/
/********************************************************************************/
struct logger_t
{
	void (*destroy)( logger_t * );

	char	 			control_file_name[FILESYSTEM_MAX_NAME_LENGTH+1];
	char				element_file_name;
	char 				head_file_name[FILESYSTEM_MAX_NAME_LENGTH+1];
	char				tail_file_name[FILESYSTEM_MAX_NAME_LENGTH+1];
	FILE				*fs;
	SemaphoreHandle_t	*sync_mutex;
	size_t				max_capacity;
};


/********************************************************************************/
/* Non Virtual Method Declares													*/
/********************************************************************************/

/**
 * @memberof logger_t
 * @brief
 * 		Get the head file - to edit.
 * @details
 * 		Use this to get a handle for the file at the HEAD of the ring buffer. If the ring buffer is empty
 * 		an error code is returned.
 * 		<br><b>The location of the write cursor is at the end of the file.</b>
 * @attention
 * 		Successive calls will result in duplicate file opening.
 * @attention
 * 		file_t::close( ) must always be called on the returned file regardless of error code.
 * @param err[out]
 * 		An error code. This argument must point to valid memory.
 * @returns
 * 		An opened handle for the file at the HEAD.
 */
int32_t logger_peek_head( logger_t*, logger_error_t* err );

/**
 * @memberof logger_t
 * @brief
 * 		Insert a file into the ring buffer.
 * @details
 *		Insert a file into the ring buffer. Since the ring buffer uses a strict naming protocol, the file will be renamed.
 * 		<br>If the ring buffer is full the oldest file will be deleted to make room.
 * @param file_name[in]
 * 		The name of the file to insert into the ring buffer, up to FILESYSTEM_MAX_NAME_LENGTH bytes (not including mandatory NULL termination).
 * 		All references (handles) to this file MUST be closed or the function will fail.
 * 		This file is renamed by the ring buffer. If the file doesn't exist
 * 		nothing is done. <b>To insert an empty file pass this argument as NULL.</b>
 * @param err[out]
 * 		Must point to valid memory as input. Outputs an error code.
 * @returns
 * 		An opened handle for the file inserted. This file must always be closed with file_t::close( ) regardless of error code.
 */
int32_t logger_insert( logger_t*, logger_error_t* err, char const* file_name );

/**
 * @memberof logger_t
 * @brief
 * 		Peek at the file in the ring buffers TAIL.
 * @details
 * 		Peek at the file in the ring buffers TAIL. The file is
 * 		not removed from the buffer. <b>The file pointer will be at the beginning of the file.</b> Note, this
 * 		is different from logger_peek_head( ) where the file pointer is at the end of the file.
 * 		Must always call file_t::close( ) when finished regardless of error code.
 * @param err[out]
 * 		Error code. This argument must point to valid memory.
 * @returns
 * 		An opened handle for the file at the TAIL. This file
 *		must be closed when finished with file_t::close( ).
 */
int32_t logger_peek_tail( logger_t*, logger_error_t* err );

/**
 * @memberof logger_t
 * @brief
 * 		Remove the file at the ring buffer's TAIL.
 * @details
 * 		Remove the file at the ring buffer's TAIL. The TAIL is increment to the next file.
 * 		This method does not delete the file from memory, it renames it. See the logger_t
 * 		description for renaming protocol.
 * @param popped_file_name[out]
 * 		The name of the popped file is copied into here. The pointer must point to at least FILESYSTEM_MAX_NAME_LENGTH+1
 * 		bytes of valid memory. Pass this argument as NULL to ignore it.
 * @returns
 * 		An error code.
 */
logger_error_t logger_pop( logger_t*, char* popped_file_name );


/********************************************************************************/
/* Initialization Method Declares												*/
/********************************************************************************/
/**
 * @memberof logger_t
 * @brief
 * 		Initialize a logger_t structure
 * @details
 * 		Initialize a logger_t structure. If this is the first time the ring buffer is initialized (ie, first system boot up
 * 		with empty non volatile memory) it will be empty.
 * @param self
 * 		The logger_t structure being constructed.
 * @param filesystem
 * 		A pointer to the filesystem_t structure the logger will use to interact with
 * 		the file system. Must remain valid in memory for the duration the <b>logger</b>
 * 		instance is used.
 * @param control_file_name[in]
 * 		Must be a null terminated string indicating the name to use for ring buffer's control data.
 * 		This name is copied up to a maximum of FILESYSTEM_MAX_NAME_LENGTH bytes. This file must not be used.
 * @param element_file_name[in]
 * 		The name of file elements. This is used to differentiate between files of different sources when
 * 		they are viewed via an FTP service and to bind files to a logger_t instance.
 * @param max_capacity
 * 		The maximum number of files the ring buffer can hold. Must be between LOGGER_MIN_CAPACITY (2) and LOGGER_MAX_CAPACITY (1000).
 * @returns
 * 		An error code.
 */
logger_error_t initialize_logger( logger_t *self,
								  char const *control_file_name, char element_file_name, size_t max_capacity, bool_t logger_is_init);
SAT_returnState start_logger_task(void);
void logger_task();



#endif /* INCLUDE_TELEMETRY_LOGGER_H_ */
